
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tractrix/docstand/server/gcp/documentation_store.go (65.0%)</option>
				
				<option value="file1">github.com/tractrix/docstand/server/gcp/repository_manager.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package gcp

import (
        "fmt"
        "time"

        "golang.org/x/net/context"
        "google.golang.org/appengine"
        "google.golang.org/appengine/datastore"

        "github.com/tractrix/common-go/gcp"
        "github.com/tractrix/common-go/repository"
        "github.com/tractrix/docstand/server/data"
)

const (
        kindDocumentation       = "Documentation"
        kindDocumentationResult = "DocumentationResult"
        kindDocumentationStatus = "DocumentationStatus"
        kindDeletingTarget      = "DeletingTarget"
)

type documentationResultEntity struct {
        Documents []data.Document
}

func newDocumentationResultEntity(result *data.DocumentationResult) (*documentationResultEntity, error) <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no documentation result specified")
        }</span>

        <span class="cov0" title="0">entity := documentationResultEntity{
                Documents: result.Documents.ListDocuments(),
        }

        return &amp;entity, nil</span>
}

func (entity *documentationResultEntity) toDocumentationResult() *data.DocumentationResult <span class="cov8" title="1">{
        return &amp;data.DocumentationResult{
                Documents: data.MakeDocumentMapFromDocuments(entity.Documents),
        }
}</span>

func (entity *documentationResultEntity) putDocument(document *data.Document) error <span class="cov8" title="1">{
        if document == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no document specified")
        }</span>

        <span class="cov8" title="1">for i, existingDoc := range entity.Documents </span><span class="cov8" title="1">{
                if existingDoc.Type == document.Type </span><span class="cov8" title="1">{
                        // entity.Documents should be updated by using an index because
                        // existingDoc is not a pointer and updating it does not affect entity.Documents.
                        entity.Documents[i] = *document
                        return nil
                }</span>
        }

        <span class="cov8" title="1">entity.Documents = append(entity.Documents, *document)

        return nil</span>
}

type documentationStatusEntity struct {
        CommitID    string
        TaskID      string
        Status      string
        RequestedAt time.Time
        UpdatedAt   time.Time
}

func (entity *documentationStatusEntity) toDocumentationStatus() *data.DocumentationStatus <span class="cov8" title="1">{
        return &amp;data.DocumentationStatus{
                CommitID:    entity.CommitID,
                TaskID:      entity.TaskID,
                Status:      entity.Status,
                RequestedAt: entity.RequestedAt,
                UpdatedAt:   entity.UpdatedAt,
        }
}</span>

type deletingTargetEntity struct {
        RequestedAt time.Time
}

// DocumentationStore loads/saves documentation data from/to Google Cloud Datastore.
// It implements data.DocumentationStore interface.
type DocumentationStore struct {
        context context.Context
}

// NewDocumentationStore returns a new DocumentationStore bound to the context.
func NewDocumentationStore(ctx context.Context) *DocumentationStore <span class="cov8" title="1">{
        return &amp;DocumentationStore{context: ctx}
}</span>

func (store *DocumentationStore) newRootKey() *datastore.Key <span class="cov8" title="1">{
        return datastore.NewKey(store.context, kindDocumentation, "root", 0, nil)
}</span>

func (store *DocumentationStore) newRepositoryIDKey(id int64) *datastore.Key <span class="cov8" title="1">{
        parentKey := store.newRootKey()
        return datastore.NewKey(store.context, kindDocumentation, "", id, parentKey)
}</span>

func (store *DocumentationStore) newReferenceTypeKey(parentKey *datastore.Key, ref *repository.Reference) (*datastore.Key, error) <span class="cov8" title="1">{
        if ref == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no repository reference specified")
        }</span>

        <span class="cov8" title="1">return datastore.NewKey(store.context, kindDocumentation, ref.Type, 0, parentKey), nil</span>
}

func (store *DocumentationStore) newDocumentationTargetKey(target *data.DocumentationTarget, kind string) (*datastore.Key, error) <span class="cov8" title="1">{
        if target == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no documentation target specified")
        }</span>

        // newReferenceTypeKey never fail
        // because &amp;target.Reference cannot be nil.
        <span class="cov8" title="1">ancestorKey := store.newRepositoryIDKey(target.RepositoryID)
        parentKey, _ := store.newReferenceTypeKey(ancestorKey, &amp;target.Reference)
        return datastore.NewKey(store.context, kind, target.Reference.Name, 0, parentKey), nil</span>
}

func (store *DocumentationStore) newDocumentationStatusKey(target *data.DocumentationTarget, status *data.DocumentationStatus) (*datastore.Key, error) <span class="cov8" title="1">{
        parentKey, err := store.newDocumentationTargetKey(target, kindDocumentationStatus)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if status == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no documentation status specified")
        }</span>
        <span class="cov8" title="1">if status.SequenceID == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no sequence id specified")
        }</span>

        <span class="cov8" title="1">return datastore.NewKey(store.context, kindDocumentationStatus, "", status.SequenceID, parentKey), nil</span>
}

func (store *DocumentationStore) getDocumentationStatusesByTarget(target *data.DocumentationTarget) ([]*data.DocumentationStatus, error) <span class="cov0" title="0">{
        // To Check : When using this as parent key, double no of entities return as output.
        // parentKey := store.newRepositoryIDKey(target.RepositoryID)

        parentKey, err := store.newDocumentationTargetKey(target, kindDocumentationStatus)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var statusArray []*data.DocumentationStatus

        err = gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov0" title="0">{

                statusQuery := datastore.NewQuery(parentKey.Kind()).Ancestor(parentKey)

                var entities []documentationStatusEntity
                keys, err := statusQuery.GetAll(transactionContext, &amp;entities)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for index, entity := range entities </span><span class="cov0" title="0">{
                        docStatus := entity.toDocumentationStatus()
                        docStatus.SequenceID = keys[index].IntID()
                        statusArray = append(statusArray, docStatus)
                }</span>

                <span class="cov0" title="0">return nil</span>

        }, nil)

        <span class="cov0" title="0">return statusArray, err</span>

}

func (store *DocumentationStore) newCommitIDKey(target *data.DocumentationTarget, kind, commitID string) (*datastore.Key, error) <span class="cov8" title="1">{
        parentKey, err := store.newDocumentationTargetKey(target, kind)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if commitID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no commit id specified")
        }</span>

        <span class="cov8" title="1">return datastore.NewKey(store.context, kind, commitID, 0, parentKey), nil</span>
}

func (store *DocumentationStore) newDeletingTargetKey(target *data.DeletingTarget) (*datastore.Key, error) <span class="cov8" title="1">{
        if target == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no deleting target specified")
        }</span>

        // newReferenceTypeKey never fail
        // because &amp;target.Reference cannot be nil.
        <span class="cov8" title="1">ancestorKey := store.newRepositoryIDKey(target.RepositoryID)
        parentKey, _ := store.newReferenceTypeKey(ancestorKey, &amp;target.Reference)
        return datastore.NewKey(store.context, kindDeletingTarget, target.Reference.Name, 0, parentKey), nil</span>
}

// CreateTarget saves a new entity for the documentation target.
// If the documentation target already exists, it returns data.ErrTargetAlreadyExists.
func (store *DocumentationStore) CreateTarget(target *data.DocumentationTarget) error <span class="cov8" title="1">{
        key, err := store.newDocumentationTargetKey(target, kindDocumentationResult)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov8" title="1">{
                err := datastore.Get(transactionContext, key, new(documentationResultEntity))
                if err == nil </span><span class="cov0" title="0">{
                        return data.ErrTargetAlreadyExists
                }</span><span class="cov8" title="1"> else if err != datastore.ErrNoSuchEntity </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = datastore.Put(transactionContext, key, new(documentationResultEntity))

                return err</span>
        }, nil)
}

// DeleteTarget deletes the documentation target.
func (store *DocumentationStore) DeleteTarget(target *data.DocumentationTarget) error <span class="cov0" title="0">{
        resultKey, err := store.newDocumentationTargetKey(target, kindDocumentationResult)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // No error must occur.
        <span class="cov0" title="0">statusAncestorKey, _ := store.newDocumentationTargetKey(target, kindDocumentationStatus)

        transactionOptions := &amp;datastore.TransactionOptions{
                XG: true,
        }
        return gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov0" title="0">{
                statusQuery := datastore.NewQuery(statusAncestorKey.Kind()).Ancestor(statusAncestorKey).KeysOnly()
                statusKeys, err := statusQuery.GetAll(transactionContext, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := datastore.DeleteMulti(transactionContext, statusKeys); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return datastore.Delete(transactionContext, resultKey)</span>
        }, transactionOptions)
}

// ExistsTarget returns true if the documentation target already exists.
// It returns false otherwise.
func (store *DocumentationStore) ExistsTarget(target *data.DocumentationTarget) (bool, error) <span class="cov8" title="1">{
        key, err := store.newDocumentationTargetKey(target, kindDocumentationResult)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = datastore.Get(store.context, key, new(documentationResultEntity))
        switch err </span>{
        <span class="cov8" title="1">case nil:
                return true, nil</span>
        <span class="cov8" title="1">case datastore.ErrNoSuchEntity:
                return false, nil</span>
        }

        <span class="cov0" title="0">return false, err</span>
}

// CountTargetsInRepository returns the number of documentation targets in the repository.
func (store *DocumentationStore) CountTargetsInRepository(id int64) (int, error) <span class="cov0" title="0">{
        key := store.newRepositoryIDKey(id)

        var numOfTargets int
        err := gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov0" title="0">{
                count, err := datastore.NewQuery(kindDocumentationResult).Ancestor(key).Count(transactionContext)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">numOfTargets = count
                return nil</span>
        }, nil)

        <span class="cov0" title="0">return numOfTargets, err</span>
}

// MarkDeletingTarget marks the documentation target as deleting.
func (store *DocumentationStore) MarkDeletingTarget(target *data.DeletingTarget) error <span class="cov8" title="1">{
        key, err := store.newDeletingTargetKey(target)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov8" title="1">{
                err := datastore.Get(transactionContext, key, new(deletingTargetEntity))
                if err == nil </span><span class="cov8" title="1">{
                        // If the entity already exists, nothing has to be done.
                        return nil
                }</span>
                <span class="cov8" title="1">if err != datastore.ErrNoSuchEntity </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">_, err = datastore.Put(transactionContext, key, &amp;deletingTargetEntity{
                        RequestedAt: time.Now().UTC(),
                })

                return err</span>
        }, nil)
}

// UnmarkDeletingTarget removes a mark of deleting from the documentation target.
func (store *DocumentationStore) UnmarkDeletingTarget(target *data.DeletingTarget) error <span class="cov8" title="1">{
        key, err := store.newDeletingTargetKey(target)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return datastore.Delete(store.context, key)</span>
}

// IsDeletingTarget checks if the target is marked as a target being deleted.
func (store *DocumentationStore) IsDeletingTarget(target *data.DeletingTarget) (bool, error) <span class="cov8" title="1">{
        key, err := store.newDeletingTargetKey(target)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">err = datastore.Get(store.context, key, new(deletingTargetEntity))
        if err == datastore.ErrNoSuchEntity </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

// GetResult loads the latest documentation information for the documentation target.
func (store *DocumentationStore) GetResult(target *data.DocumentationTarget) (*data.DocumentationResult, error) <span class="cov8" title="1">{
        key, err := store.newDocumentationTargetKey(target, kindDocumentationResult)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var entity documentationResultEntity
        if err := datastore.Get(store.context, key, &amp;entity); err != nil </span><span class="cov0" title="0">{
                if err == datastore.ErrNoSuchEntity </span><span class="cov0" title="0">{
                        return nil, data.ErrNoSuchTarget
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return entity.toDocumentationResult(), nil</span>
}

// GetResultMulti is a batch version of GetLatestResult.
func (store *DocumentationStore) GetResultMulti(targets []*data.DocumentationTarget) (map[*data.DocumentationTarget]*data.DocumentationResult, error) <span class="cov0" title="0">{
        var keys []*datastore.Key
        keys2Targets := make(map[*datastore.Key]*data.DocumentationTarget)
        for _, target := range targets </span><span class="cov0" title="0">{
                key, err := store.newDocumentationTargetKey(target, kindDocumentationResult)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">keys = append(keys, key)
                keys2Targets[key] = target</span>
        }

        // TODO: Reconsider how to handle MultiError.
        <span class="cov0" title="0">entities := make([]*documentationResultEntity, len(keys))
        if err := datastore.GetMulti(store.context, keys, entities); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(appengine.MultiError); !ok </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">results := make(map[*data.DocumentationTarget]*data.DocumentationResult)
        for index, entity := range entities </span><span class="cov0" title="0">{
                if entity != nil </span><span class="cov0" title="0">{
                        target := keys2Targets[keys[index]]
                        results[target] = entity.toDocumentationResult()
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// PutDocument saves the document information as the latest one for the documentation target.
func (store *DocumentationStore) PutDocument(target *data.DocumentationTarget, document *data.Document) error <span class="cov8" title="1">{
        key, err := store.newDocumentationTargetKey(target, kindDocumentationResult)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov8" title="1">{
                var entity documentationResultEntity
                if err := datastore.Get(transactionContext, key, &amp;entity); err != nil </span><span class="cov8" title="1">{
                        if err == datastore.ErrNoSuchEntity </span><span class="cov8" title="1">{
                                return data.ErrNoSuchTarget
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">if err := entity.putDocument(document); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err := datastore.Put(transactionContext, key, &amp;entity)

                return err</span>
        }, nil)
}

// CreateStatus saves a new entity for the documentation status.
func (store *DocumentationStore) CreateStatus(target *data.DocumentationTarget, status *data.DocumentationStatus) error <span class="cov8" title="1">{
        key, err := store.newDocumentationStatusKey(target, status)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return gcp.NewDefaultDatastoreTransaction().Run(store.context, func(tc context.Context) error </span><span class="cov8" title="1">{
                err := datastore.Get(tc, key, new(documentationStatusEntity))
                if err == nil </span><span class="cov8" title="1">{
                        return data.ErrStatusAlreadyExists
                }</span>
                <span class="cov8" title="1">if err != datastore.ErrNoSuchEntity </span><span class="cov0" title="0">{
                        return err
                }</span>

                // time.Time is stored with microsecond precision into datastore.
                // See https://cloud.google.com/appengine/docs/go/datastore/reference also.
                <span class="cov8" title="1">currentUTCTime := time.Now().UTC().Round(time.Microsecond)
                entity := &amp;documentationStatusEntity{
                        CommitID:    status.CommitID,
                        TaskID:      status.TaskID,
                        Status:      status.Status,
                        RequestedAt: currentUTCTime,
                        UpdatedAt:   currentUTCTime,
                }
                _, err = datastore.Put(store.context, key, entity)
                return err</span>
        }, nil)
}

// GetStatus loads the documentation status for the documentation target.
func (store *DocumentationStore) GetStatus(target *data.DocumentationTarget, sequenceID int64) (*data.DocumentationStatus, error) <span class="cov8" title="1">{
        key, err := store.newDocumentationStatusKey(target, &amp;data.DocumentationStatus{SequenceID: sequenceID})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var entity documentationStatusEntity
        if err := datastore.Get(store.context, key, &amp;entity); err != nil </span><span class="cov8" title="1">{
                if err == datastore.ErrNoSuchEntity </span><span class="cov8" title="1">{
                        return nil, data.ErrNoSuchStatus
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">status := entity.toDocumentationStatus()
        status.SequenceID = sequenceID
        return status, nil</span>
}

// GetStatusMulti loads the documentation status for the multiple documentation targets of a given repository
func (store *DocumentationStore) GetStatusMulti(targets []*data.DocumentationTarget) (map[*data.DocumentationTarget][]*data.DocumentationStatus, error) <span class="cov0" title="0">{
        targets2StatusArrays := make(map[*data.DocumentationTarget][]*data.DocumentationStatus)

        for _, target := range targets </span><span class="cov0" title="0">{
                statusArray, err := store.getDocumentationStatusesByTarget(target)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">targets2StatusArrays[target] = statusArray</span>
        }

        <span class="cov0" title="0">return targets2StatusArrays, nil</span>
}

// UpdateStatus updates the existing documentation status with the given one.
func (store *DocumentationStore) UpdateStatus(target *data.DocumentationTarget, status *data.DocumentationStatus) error <span class="cov8" title="1">{
        return store.updateStatus(target, status, func(entity *documentationStatusEntity) error </span><span class="cov8" title="1">{
                return nil
        }</span>)
}

// UpdateStatusWithCondition updates the existing documentation status with the given one
// if the current status is equal to prevStatus, or returns an error otherwise.
func (store *DocumentationStore) UpdateStatusWithCondition(target *data.DocumentationTarget, status *data.DocumentationStatus, prevStatus string) error <span class="cov8" title="1">{
        return store.updateStatus(target, status, func(entity *documentationStatusEntity) error </span><span class="cov8" title="1">{
                if entity.Status != prevStatus </span><span class="cov8" title="1">{
                        return data.ErrUnsatisfiedStatusCondition
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
}

func (store *DocumentationStore) updateStatus(target *data.DocumentationTarget, status *data.DocumentationStatus, conditionCheckFunc func(*documentationStatusEntity) error) error <span class="cov8" title="1">{
        key, err := store.newDocumentationStatusKey(target, status)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return gcp.NewDefaultDatastoreTransaction().Run(store.context, func(tc context.Context) error </span><span class="cov8" title="1">{
                entity := new(documentationStatusEntity)
                err := datastore.Get(tc, key, entity)
                if err == datastore.ErrNoSuchEntity </span><span class="cov8" title="1">{
                        return data.ErrNoSuchStatus
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := conditionCheckFunc(entity); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // time.Time is stored with microsecond precision into datastore.
                // See https://cloud.google.com/appengine/docs/go/datastore/reference also.
                // And furthermore, RequestedAt should not be updated.
                <span class="cov8" title="1">entity.CommitID = status.CommitID
                entity.TaskID = status.TaskID
                entity.Status = status.Status
                entity.UpdatedAt = time.Now().UTC().Round(time.Microsecond)
                _, err = datastore.Put(store.context, key, entity)
                return err</span>
        }, nil)
}

// QueryStatus returns a list of documentation status as the result of querying on the documentation target by the status.
func (store *DocumentationStore) QueryStatus(target *data.DocumentationTarget, status string) ([]*data.DocumentationStatus, error) <span class="cov8" title="1">{
        key, err := store.newDocumentationTargetKey(target, kindDocumentationStatus)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var statuses []*data.DocumentationStatus
        err = gcp.NewDefaultDatastoreTransaction().Run(store.context, func(transactionContext context.Context) error </span><span class="cov8" title="1">{
                query := datastore.NewQuery(key.Kind()).Ancestor(key).Filter("Status =", status)
                var entities []documentationStatusEntity
                keys, err := query.GetAll(transactionContext, &amp;entities)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for index, entity := range entities </span><span class="cov8" title="1">{
                        docStatus := entity.toDocumentationStatus()
                        docStatus.SequenceID = keys[index].IntID()
                        statuses = append(statuses, docStatus)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }, nil)

        <span class="cov8" title="1">return statuses, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package gcp

import (
        "fmt"
        "net/http"
        "net/url"
        "time"

        "golang.org/x/net/context"
        "google.golang.org/appengine"
        "google.golang.org/appengine/urlfetch"

        "github.com/tractrix/common-go/client/repository"
        "github.com/tractrix/common-go/gcp"
)

const (
        docstandProjectID       = "docstand-prod"
        repositoryManagerModule = "repository-manager"
        tractrixCoreProjectID   = "planar-oasis-88707"
        localTractrixCoreDomain = "localhost:9003"

        repositoryManagerTimeout = 60 * time.Second
)

// NewRepositoryManagerClient returns a new client for repository-manager module running in the Google App Engine.
func NewRepositoryManagerClient(ctx context.Context) *repository.ManagerClient <span class="cov0" title="0">{
        // repository manager is running in tractrix core project
        hostName := fmt.Sprintf("%s-dot-%s.appspot.com", repositoryManagerModule, tractrixCoreProjectID)
        apiURL := &amp;url.URL{
                Scheme: "https",
                Host:   hostName,
                Path:   "/api/1/",
        }

        deadline := time.Now().Add(repositoryManagerTimeout)
        ctxWithDeadline, _ := context.WithDeadline(ctx, deadline)
        client := &amp;http.Client{
                Transport: &amp;urlfetch.Transport{
                        Context: ctxWithDeadline,
                },
        }

        // NOTE: During inter-module communication on development app server,
        //       login information is not shared with the destination module.
        //       Actually, the login information is attached to HTTP request
        //       in the current context as a cookie, so it can be provided to
        //       the destination module also as a cookie as a workaround.
        if appengine.IsDevAppServer() </span><span class="cov0" title="0">{
                apiURL.Scheme = "http"
                apiURL.Host = localTractrixCoreDomain

                // Error will not occur because valid endpoint is always passed
                client.Jar, _ = gcp.NewCookieJarWithDummyAdminUserInfo(apiURL)
        }</span>

        <span class="cov0" title="0">return repository.NewManagerClient(client, apiURL, docstandProjectID)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
